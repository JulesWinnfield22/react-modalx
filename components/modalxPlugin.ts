import fs from 'node:fs';
import path from 'node:path';
import type { Plugin, ViteDevServer } from 'vite';

function findAllFiles(dir: string, extensions: string[], blacklist: string[], rootPath: string): string[] {
  let results: string[] = [];
  if (!fs.existsSync(dir)) return results;

  const list = fs.readdirSync(dir);

  for (const file of list) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat && stat.isDirectory()) {
      if (blacklist.includes(file)) continue;
      results = results.concat(findAllFiles(filePath, extensions, blacklist, rootPath));
    } else {
      if (extensions.some(ext => file.endsWith(ext))) {
        results.push(filePath);
      }
    }
  }
  return results;
}

export function modalTypesPlugin(_options = {}): Plugin {
  const expansions = [".amdl.tsx", ".mdl.tsx", ".amdl.jsx", ".mdl.jsx"];
  const blacklist = ["node_modules", "dist", ".git"];

  let rootPath = "";
  let outFile = "";

  return {
    name: "modalx",
    apply: "serve",
    configResolved(config) {
      rootPath = config.root;
      outFile = path.resolve(rootPath, "src/components/new_modal_2.0/FileNameEnums.ts");
    },
    configureServer(server: ViteDevServer) {
      const generateTypes = () => {
        try {
          const modalFiles = findAllFiles(rootPath, expansions, blacklist, rootPath);
          const imports: string[] = [];
          const mapping: string[] = [];
          const typeAliases: string[] = [];
          const constantMembers: string[] = [];
          const modalNames: string[] = [];

          const outDir = path.dirname(outFile);

          modalFiles.forEach((file) => {
            const name = path.basename(file).split('.')[0];
            const content = fs.readFileSync(file, 'utf-8');
            const hasReturnType = /export\s+type\s+ReturnType/.test(content);

            let importPath = path.relative(outDir, file);
            if (!importPath.startsWith('.')) importPath = './' + importPath;
            importPath = importPath.replace(/\.(tsx|jsx|ts|js)$/, '');

            const importAlias = `ReturnType_${name}`;
            const relPath = path.relative(rootPath, file);

            // Documentation block
            const jsDoc = `  /** 
   * @source ${relPath}
   * @see {@link file://${file}}
   */`;

            // Create an exported type alias for each modal
            typeAliases.push(`${jsDoc}\nexport type ${name} = '${name}';`);
            constantMembers.push(`${jsDoc}\n  ${name}: '${name}' as ${name},`);
            modalNames.push(name);

            if (hasReturnType) {
              imports.push(`import type { ReturnType as ${importAlias} } from '${importPath}';`);
              mapping.push(`${jsDoc}\n  '${name}': ${importAlias};`);
            } else {
              mapping.push(`${jsDoc}\n  '${name}': any;`);
            }
          });

          const typeContent = `// Auto-generated by vite-plugin-modal-types
${imports.join('\n')}

export interface ModalRegistry {
${mapping.join('\n')}
}

${typeAliases.join('\n\n')}

/**
 * Constant object for all modal names.
 * Use this for better "Go to Definition" support: openModal(MODALS.ConfirmationModal)
 */
export const MODALS = {
${constantMembers.join('\n')}
} as const;

export type FileNames = ${modalNames.join(' | ') || 'never'};
`;

          if (
            !fs.existsSync(outFile) ||
            fs.readFileSync(outFile, "utf-8") !== typeContent
          ) {
            fs.mkdirSync(path.dirname(outFile), { recursive: true });
            fs.writeFileSync(outFile, typeContent);
            console.log(`\n✨ Updated modal types (${modalFiles.length} modals)`);
          }
        } catch (error) {
          console.error("\n⚠️ Modal type generation failed:", error);
        }
      };

      generateTypes();

      server.watcher.on("add", (file) => {
        if (expansions.some(ext => file.endsWith(ext))) generateTypes();
      });
      server.watcher.on("unlink", (file) => {
        if (expansions.some(ext => file.endsWith(ext))) generateTypes();
      });
      server.watcher.on("change", (file) => {
        if (expansions.some(ext => file.endsWith(ext))) generateTypes();
      });
    },
  };
}